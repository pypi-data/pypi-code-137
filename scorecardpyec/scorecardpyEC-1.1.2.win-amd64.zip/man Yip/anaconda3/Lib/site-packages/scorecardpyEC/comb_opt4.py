# -*- coding: utf-8 -*-
"""
Created on Tue Mar  8 15:08:42 2022

@author: man Yip
"""

import numpy as np
import pandas as pd
import time

class OptBin():
    def __init__(self,X,y,min_dis):
        self.X = X
        self.y = y
        self.min_dis = min_dis
    
    def get_bins(self):
        bins={}
        for c in self.X.columns:
            bins[c] = self.get_one_bin(c)
        return bins
    
class Bin_Path():
    def __init__(self,path=[-np.inf],sum_iv=0,lastest_y_mean=None):
        self.path=path
        self.sum_iv = sum_iv
        self.lastest_y_mean = lastest_y_mean
        
class OptBinOne():
    def __init__(self,x,y,min_dis,spec_values=None):
        self.x = x
        self.x_valid = x.loc[x.notna()]
        if spec_values is not None:
            self.x_valid = self.x_valid.loc[~self.x_valid.isin(spec_values)]
        self.__prev_handle()
        
        self.y = y
        self.all_bad = self.y[self.y==1].shape[0]
        self.all_good = self.y[self.y==0].shape[0]
        self.min_dis = min_dis
        self.spec_values = spec_values
        self.bin_points = [-np.inf,np.inf]
        self.MAX_IV=0
        self.x_point = self.__truncate_two_side()
        print(self.x_point.shape)
        self.connable_table = self.__connable_table()
        self.gradient = self.__get_gradient()
        self.start_time = time.time()
        self.__calc_maxiv_mon_bin(Bin_Path())

    def __truncate_two_side(self):
        vc = self.x_valid.value_counts().sort_index()/self.x.shape[0]
        tmp = vc.cumsum()
        tmp = tmp[tmp >= self.min_dis]
        if len(tmp) <= 1:
            return [-np.inf,np.inf]
        
        tmp = tmp.iloc[1:]
        tmp2 = vc.iloc[::-1].cumsum()
        tmp2 = tmp2.loc[tmp2.index.isin(tmp.index)]
        tmp2 = tmp2.loc[tmp2 >= self.min_dis]
        
        if len(tmp2) < 1:
            return [-np.inf,np.inf]
        
        head = pd.Series([vc.iloc[0]],[-np.inf])
        tail_dis = pd.Series([vc.iloc[-1]],[np.inf])
        tail_cum = pd.Series([self.x_valid.shape[0]/self.x.shape[0]],[np.inf])
  
        x_point_cum = tmp.loc[tmp.index.isin(tmp2.index)]
        x_point_dis = vc.loc[vc.index.isin(x_point_cum.index)]
        
        x_point_cum = pd.concat([head,x_point_cum,tail_cum])
        x_point_dis = pd.concat([head,x_point_dis,tail_dis])
        
        x_point = pd.concat([x_point_cum,x_point_dis],axis=1)
        x_point.columns=['cum','dis']
        return x_point
    
    def __connable_table(self):
        def _f1(ind):
            tmp = self.x_point['cum']-self.x_point.loc[ind]['cum']-self.x_point['dis']+self.x_point.loc[ind]['dis']
            tmp = tmp[tmp>=self.min_dis]
            tmp = tmp.index.values    
            return tmp     
        return self.x_point.index.to_series().apply(_f1)
    
    def __get_gradient(self):
        from sklearn import linear_model
        x=self.x_valid.sample(frac=1)
        x = pd.DataFrame(x)
        y=self.y.loc[x.index]
        clf = linear_model.LogisticRegression().fit(x,y)
        return clf.coef_[0][0]
    
    def __get_iv(self,bin_y_sample):
        bin_bad = bin_y_sample[bin_y_sample==1].shape[0]
        bin_good = bin_y_sample[bin_y_sample==0].shape[0]
        
        iv=((bin_bad/self.all_bad)-(bin_good/self.all_good))*np.log((bin_bad/self.all_bad)/(bin_good/self.all_good))
        return np.around(iv,4)
    
    def __get_bin_y_sample(self,s,e):
        bin_y_sample = self.x_valid.loc[(self.x_valid >= s) & (self.x_valid < e)]
        bin_y_sample = self.y.loc[bin_y_sample.index]
        return bin_y_sample
    
    
    
    # def __check(self,start,mid,end):
    #     y1_mean = np.around(self._get_bin_y_sample(start,mid).mean(),2)
    #     y2_mean = np.around(self._get_bin_y_sample(mid,end).mean(),2)
    #     if y1_mean == 0 or y2_mean==0 or y1_mean == 1 or y2_mean==1:
    #         return False
    #     return (y2_mean - y1_mean) * self.gradient > 0
    
    # def __first_check(self,start,end):
    #     y_mean = np.around(self._get_bin_y_sample(start,end).mean(),2)
    #     if y_mean==0 or y_mean==1:
    #         return False
    #     return True
           
    def __calc_maxiv_mon_bin(self,bin_path):  
        curr = bin_path.path[-1]
        # max_num = 25
        if curr != np.inf:
            targets = self.connable_table[curr]
            # if len(targets)>=max_num:
            #     targets=targets[0:max_num]
            for target in targets:
                bin_y_sample = self.__get_bin_y_sample(curr,target)
                bin_y_sample_mean = np.around(bin_y_sample.mean(),2)
                if bin_y_sample_mean == 0 or bin_y_sample_mean==1:
                    continue
                if bin_path.lastest_y_mean is not None:
                    if (bin_y_sample_mean - bin_path.lastest_y_mean)*self.gradient <=0:
                        continue
                self.__calc_maxiv_mon_bin(Bin_Path(bin_path.path + [target],bin_path.sum_iv+self.__get_iv(bin_y_sample),bin_y_sample_mean))
        else:
            if bin_path.sum_iv > self.MAX_IV:
                self.MAX_IV = bin_path.sum_iv
                self.bin_points = bin_path.path
                 
    def __prev_handle(self):
        return 1
    
    
def get_test_data():
    import pickle
    import pandas as pd
    file= 'D:/work2/MODEL A/20220103/BR/credit/ws/1_datas.pkl'
    with open(file,'rb') as f:
        data = pickle.load(f)
    return pd.concat(data.values()).sort_index()
data = get_test_data()
f = 'ALS_M3_ID_NBANK_ORGNUM'
# a = data[f].value_counts(dropna=False).sort_index()/data.shape[0]
# a.to_excel('c:/tmp/a.xlsx')

t1=time.time()
obo = OptBinOne(data[f],data['y'],0.02)
t2=time.time()
print(obo.MAX_IV)
print(obo.bin_points)
print(t2-t1)

points = obo.bin_points
for i,v in enumerate(points):
    tmp1 = np.around(data.loc[(data[f]>=v) & (data[f]<points[i+1]),'y'].mean(),2)
    tmp2 = np.around(data.loc[(data[f]>=v) & (data[f]<points[i+1]),'y'].shape[0]/data.shape[0],2)
    print(tmp1,tmp2)
    if tmp2 < 0.02:
        print('***********************')
    if v != -np.inf:
        tmp3 = np.around(data.loc[(data[f]>=points[i-1]) & (data[f]<v),'y'].mean(),2)
        if tmp3 - tmp1 >= 0:
            print('---------------------------------')
    if points[i+1] == np.inf:
        break
# obo.x_point.to_excel('c:/tmp/b.xlsx')
# obo.connable_table.to_excel('c:/tmp/c.xlsx')


