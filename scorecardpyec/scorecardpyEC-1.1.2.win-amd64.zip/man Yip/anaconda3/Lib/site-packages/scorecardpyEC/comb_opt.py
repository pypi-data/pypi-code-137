# -*- coding: utf-8 -*-
"""
Created on Fri Jan 28 10:24:29 2022

@author: man Yip
"""
import numpy as np
import pandas as pd
from itertools import combinations

class CombOpt():
    def __init__(self,X,y,min_dis):
        self.X = X
        self.y = y
        self.min_dis = min_dis
    
    def get_bins(self):
        bins={}
        for c in self.X.columns:
            bins[c] = self.get_one_bin(c)
        return bins
    
class CombOptOne():
    def __init__(self,x,y,min_dis,spec_values=None):
        self.x = x
        self.x_valid = x.loc[x.notna()]
        if spec_values is not None:
            self.x_valid = self.x_valid.loc[~self.x_valid.isin(spec_values)]
        self.prev_handle()
        self.y = y
        self.min_dis = min_dis
        self.x_point = self.truncate_two_side()
        self.min_breaks_num = 1
        #+1是为了方便后续统一处理
        self.max_breaks_num = int(min(1/self.min_dis,len(self.x_point)-2))+1
        self.illegals=[]
        self.gradient = self.__get_gradient()
        self.iter_breaks_num()
        
    #去掉了长尾，使之能够保证：
    #1.x_valid.loc[x_valid < x_point[1]]的占比大于min_dis
    #2.x_valid.loc[x_valid >= x_point[-2]]的占比大于min_dis
    #注：x_point[0]=-inf  x_point[-1]=inf，将inf强制加入两端
    def truncate_two_side(self):
        vc = self.x_valid.value_counts().sort_index()/self.x.shape[0]
        tmp = vc.cumsum()
        tmp = tmp[tmp >= self.min_dis]
        if len(tmp) <= 1:
            return [-np.inf,np.inf]
        
        tmp = tmp.iloc[1:].index
        tmp2 = vc.iloc[::-1].cumsum()
        tmp2 = tmp2.loc[tmp2.index.isin(tmp)]
        tmp2 = tmp2.loc[tmp2 >= self.min_dis]
        
        if len(tmp2) < 1:
            return [-np.inf,np.inf]
        tmp2 = tmp2.iloc[::-1]
        x_point = [-np.inf]
        x_point.extend(tmp2.index)
        x_point.append(np.inf)
        return x_point 
    
    def __get_gradient(self):
        from sklearn import linear_model
        x=self.x_valid.sample(frac=1)
        x = pd.DataFrame(x)
        y=self.y.loc[x.index]
        clf = linear_model.LogisticRegression().fit(x,y)
        return clf.coef_[0][0]
    
    def __is_ilg(self,comb):
        tmp = [-np.inf,np.inf]
        tmp.extend(comb)
        tmp = set(tmp)
        for ilg in self.illegals:
            if tmp >= ilg:
                return True
        return False
    
    def __get_x_range_y(self,start,end):
        tmp = self.x_valid.loc[(self.x_valid >= start) & (self.x_valid < end)]
        tmp = self.y.loc[tmp.index]
        b = (tmp.shape[0] / self.x.shape[0]) >= self.min_dis
        return tmp,b
        
    
    def __is_available_comb(self,comb):
        for i, brk in enumerate(comb):
            start = brk
            if i < len(comb)-1:
                end = comb[i+1]
            else:
                end = np.inf

            if i <len(comb)-1:
                tmp2 = self.__get_x_range_y(start,end)
                if not tmp2[1]:
                    self.illegals.append({start,end})
                    return False
            
            if i==0:
                prev=-np.inf
            else:
                prev = comb[i-1]
            tmp1 = self.__get_x_range_y(prev,start)
            tmp = (tmp2[0].mean() - tmp1[0].mean()) * self.gradient     
            
            if tmp < 0:
                self.illegals.append({prev,start,end})
                return False
    
        return True
    
    def __is_available_breaks_num(self,breaks_num):
        print(self.x_point[1:-1],breaks_num)
        print('=====================')
        for comb in combinations(self.x_point[1:-1],breaks_num):
            
            if not self.__is_ilg(comb):
                if self.__is_available_comb(comb):
                    return True
        return False
               
    def iter_breaks_num(self):
        while(True):
            breaks_num = int((self.max_breaks_num - self.min_breaks_num)/2) + self.min_breaks_num
            if breaks_num == self.min_breaks_num:
                #最终确定的breaks_num即为self.min_breaks_num
                break
            if self.__is_available_breaks_num(breaks_num):
                self.min_breaks_num = breaks_num
            else:
                self.max_breaks_num = breaks_num
    
    def prev_handle(self):
        return 1
    
                    

def get_test_data():
    import pickle
    import pandas as pd
    file= 'D:/work2/MODEL A/20220103/BR/credit/ws/1_datas.pkl'
    with open(file,'rb') as f:
        data = pickle.load(f)
    return pd.concat(data.values()).sort_index()
data = get_test_data()

f = 'ALS_M12_CELL_NBANK_CF_ALLNUM'
# f = 'ALS_M12_CELL_REL_ALLNUM'
coo = CombOptOne(data[f],data['y'],0.02)
print(coo.min_breaks_num)
data[f].value_counts(dropna=False).sort_index()
