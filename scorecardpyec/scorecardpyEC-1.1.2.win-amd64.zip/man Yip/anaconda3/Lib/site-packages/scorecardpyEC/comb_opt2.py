# -*- coding: utf-8 -*-
"""
Created on Tue Mar  8 15:08:42 2022

@author: man Yip
"""

import numpy as np
import pandas as pd
from itertools import combinations

class CombOpt():
    def __init__(self,X,y,min_dis):
        self.X = X
        self.y = y
        self.min_dis = min_dis
    
    def get_bins(self):
        bins={}
        for c in self.X.columns:
            bins[c] = self.get_one_bin(c)
        return bins
    
class CombOptOne():
    def __init__(self,x,y,min_dis,spec_values=None):
        self.x = x
        self.x_valid = x.loc[x.notna()]
        if spec_values is not None:
            self.x_valid = self.x_valid.loc[~self.x_valid.isin(spec_values)]
        self.prev_handle()
        self.y = y
        self.min_dis = min_dis
        self.x_point = self.truncate_two_side()
        self.gradient = self.__get_gradient()
        self.__build_level_tree()

    def truncate_two_side(self):
        vc = self.x_valid.value_counts().sort_index()/self.x.shape[0]
        tmp = vc.cumsum()
        tmp = tmp[tmp >= self.min_dis]
        if len(tmp) <= 1:
            return None
        
        tmp = tmp.iloc[1:]
        tmp2 = vc.iloc[::-1].cumsum()
        tmp2 = tmp2.loc[tmp2.index.isin(tmp.index)]
        tmp2 = tmp2.loc[tmp2 >= self.min_dis]
        
        if len(tmp2) < 1:
            return None
        x_point = tmp.loc[tmp.index.isin(tmp2.index)]
        return x_point
    
    def __get_gradient(self):
        from sklearn import linear_model
        x=self.x_valid.sample(frac=1)
        x = pd.DataFrame(x)
        y=self.y.loc[x.index]
        clf = linear_model.LogisticRegression().fit(x,y)
        return clf.coef_[0][0]

    
    def __get_x_range_y(self,start,end):
        tmp = self.x_valid.loc[(self.x_valid >= start) & (self.x_valid < end)]
        tmp = self.y.loc[tmp.index]
        b = (tmp.shape[0] / self.x.shape[0]) >= self.min_dis
        return tmp,b
    

    def __build_level_tree(self):
        for i,k in enumerate(self.x.point):
            prev_dis = 0
            if i > 0:
                prev_dis = self.x.point.iloc[i+1]
            
                
            
    
    def prev_handle(self):
        return 1
    
                    

def get_test_data():
    import pickle
    import pandas as pd
    file= 'D:/work2/MODEL A/20220103/BR/credit/ws/1_datas.pkl'
    with open(file,'rb') as f:
        data = pickle.load(f)
    return pd.concat(data.values()).sort_index()
data = get_test_data()

f = 'ALS_M12_CELL_NBANK_CF_ALLNUM'
# f = 'ALS_M12_CELL_REL_ALLNUM'
coo = CombOptOne(data[f],data['y'],0.02)
data[f].value_counts(dropna=False).sort_index()/data.shape[0]
